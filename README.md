
Pentru rezolvarea taskului 1, am parcurs matricea asociata imaginii folosind in principal 2 indici, memorati in registerele esi si edi: esi este indicele prin intermediul caruia identific linia curenta din matrice parcursa la un anume pas iar edi retine indexul prin intermediul caruia sunt accesate elementele din matrice (matricea asociata imaginii este vizualizata precum un vector). Pentru a identifica daca s-a ajuns pe ultima coloana a matricii, am realizat impartirea lui edi la [img_width]: daca restul impartirii este 0, atunci s-a ajuns pe ultima coloana deci se va incrementa indicele de linie(esi); Am retinut in registrul ecx valoarea cheii generate; la fiecare noua cheie generata aplic operatia xor asupra unei pixel din matrice(extras intr-un alt registru, a.i. nu se fac modificari asupra matricii initiale). Apoi compar pixelul xorat cu litera "r"; daca s-a identificat aceasta litera, voi xora si urmatorii pixeli de dupa pixelul curent, verificand daca acestia contin literele e,v,i,e,n,t; daca cel putin o litera nu este cea corecta, atunci voi trece cu xorarea la urmatorul pixel din matrice, repetand operatiile de comparare pornind din nou de la litera "r". Atunci cand a fost identificat intreg cuvantul, voi folosi indicele esi pentru a identifica linia, calculand indexul primului byte al liniei; voi xora pixelii de pe acea linie cu valoarea gasita a lui key, afisam mesajul caracter cu caracter.

Pentru rezolvarea taskului 2, am definit functiile "my_codify" si "add_line"; initial am redefinit si functia de la task1 pentru a obtine valorile lui key si line, preluandu-le pe acestea din registrele ecx(key) si esi(line). Functia my_codify(primind ca argument valoarea unei key) parcurge matricea asa cu a fost parcursa si in cadrul taskului 1 si aplica operatia xor asupra matricii, folosind valoarea lui key pe care o primeste ca si parametru. Am folosit functai my_codify pentru a aplica valoarea pentru vechiul key asupra intregii matrici din [img], apoi am apelat "add_line" pentru a adauga mesajul specificat in matrice, si in final am reapelat my_codify (de data aceasta cu valoarea noului key calculat duap formula) pentru a aplica noua cheie pe matricea in care s-a inserat mesajul.

Pentru rezolvarea taskului 3, a fost initial nevoie sa preiau argumentele data la executie programului si sa convertesc indexul byte-ului la intreg, folosindu-ma de functia atoi. In cadrul functiei "morse_encrypt" am parcurs mesajul caracter cu caracter, comparand fiecare caracter cu literele alfabetului. Pentru fiecare caracter am pus in matrice (la pozitia identificata prin indexul primit ca parametru de functie), codurile ascii ale caracterelor aferente reprezentarii acelei litere in cod Morse; dupa fiecare litera am adaugat spatiu. Am verificat la fiecare pas daca am ajuns la finalul mesajului prin compararea byte-ului curent din mesaj cu terminatorul de sir(la finalul codificarii am adaugat in matrice si acest caracter).

Pentru rezolvarea taskului 4, a fost nevoie sa preiau argumentele date la executie asa cum facut si in cadrul taskului 3. Pentru a realiza codificarea, intial am calculat lungimea sirului care trebuie codificat in imagine, multiplicand-o cu 8 pentru a obtine lungimea ca numar de biti necesari reprezentarii. Am preluat fiecare bit din mesaj dar si lsb-ul pixelului aferent din matrice; am comparat cei 2 biti; in cazul in care cei 2 sunt egali, nu se mai fac modificari asupra pixelului din matrice; in care contrar am incrementat sau decrementat valoarea pixelului.
Pentru rezolvarea taskului 5, am parcurs matricea incepand cu indexul specificat ca parametru, preluand valorea lsb-ului fiecarui element. Am folosit registrele ecx si esi pentru a putea 'grupa' bitii extrasi cate 8 (pe baza catului si restului imparitii acestora la 8). La fiecare nou pixel parcurs am setat in registrul 'edi' bitul de pe poztia data prin ecx cu valoarea bitului preluat din byte-ul curent al matricii. Astfel, dupa fiecare 8 biti parcursi (adica obtinerea unui nou caracter), resetez la 0 registrul ebx. Cand a fost obtinut in ebx caracterul 0, adica terminatorul de sir, stim ca am ajuns la finalul mesajului.

Pentru rezolvarea taskului 6, am folosit o variabila neinitializata declarata in .bss ('my_new_img'), rezervand o zona de memorie suficient de mare pentru a putea memora la adresa identificata de aceasta valorile din matricele date in ./inputs. Initial am parcurs matricea primita ca argument de functia 'blur' pentru a copia la adresa 'my_new_img' valorile din matricea nealterata. Apoi am parcurs matricea 'img', pixel cu pixel, exceptand elemenetele de pe prima si ultima coloana, respectiv prima si ultima linie; in cadrul acestei parcurgeri am calculat suma vecinilor fiecarui pixel si am plasat media acestora la adresa corespunzatoare din 'my_new_img'. In final, am mers din nou la adesa identificata prin 'my_new_img', preluand elementele matricii modificate si suprascriind pixelii din matricea initiala 'img' cu cei de la adresa la care am memorat matricea modificata. Am ales sa folosesc o variabila declarata in .bss deoarece daca as fi aplicat modificari element cu element asupra matricii initiale chiar la adresele aferente asociate lui 'img', valorile urmatoare calculate ar depinde de cele anterior calculate, ceea ce duce la rezultate eronate pentru ca modificarile de blur se fac mereu cu elemente din matricea initiala, nealterata.






